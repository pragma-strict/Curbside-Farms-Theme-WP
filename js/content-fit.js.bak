
let HERO_IMAGE_ASPECT_RATIO = 921/1920;   // height/width in px of the images
let SCALING_PERMISSIBLE_ERROR = 25;
let NUM_SCALING_PHASES = 5;
let contentScalingPhases = [
   "font-reduction",
   "hero",
   "padding",
   "font-expansion",
   "full-page"
];

// Font reducing phase definition 
let fontSizeMAX = 14;

// Hero phase definition 
let heroImageVisibleMIN = 100;

// Padding phase definition
let paddingMIN = 10;
let paddingMAX = 100;

// Current layout variables. These save us having to get these values from CSS all the time.
let cr_ContentScalingPhase = 0;
let cr_heroImageVisible = heroImageVisibleMIN;
let cr_fontSize = 14;
let cr_padding = paddingMIN;


// Set the layout to its original layout.
/* NOTE: I need to decide what the initial layout should be. It's probably important to set it tho. */
function initializeLayout(){
   document.getElementById("fp-main").children[2].style.fontSize = cr_fontSize + "pt";
   updateHeroPosition();

   // Also update the padding on the top of fp-main so that it's always visible.
   document.getElementById("fp-main").style.top = cr_heroImageVisible + "px";
}


// Make sure the hero image is positioned at the correct visible amount
function updateHeroPosition(){
   var heroImage = document.getElementById("hero-image");
   var imageHeight = window.innerWidth * HERO_IMAGE_ASPECT_RATIO;

   // It's possible that the imageHeight was reduced since the cr_heroImageVisible was set
   // which would result in the image being positioned too low. 
   if(cr_heroImageVisible > imageHeight){ 
      cr_heroImageVisible = imageHeight;
   }
   //heroImage.style.top = (-imageHeight + cr_heroImageVisible) + "px";

   // Also update the padding on the top of fp-main so that it's always visible.
   document.getElementById("fp-main").style.top = cr_heroImageVisible + "px";
}


/* This is the complete process that sets the size and positions of all content in order
   to make it completely responsive */
function updateLayout(){
   //console.log("updating layout...")
   let errorBefore = calculateScalingError();
   
   // The goal of this loop is to reduce error until it is within permissible limits
   //while(errorBefore < 0 || errorBefore > SCALING_PERMISSIBLE_ERROR){
      //console.log("error at loop begin: " + errorBefore)
      
      // IF FONT REDUCING PHASE
      if(contentScalingPhases[cr_ContentScalingPhase] == "font-reduction")  
      {
         updateFontSize(errorBefore);
      }
      
      // IF HERO PHASE
      else if(contentScalingPhases[cr_ContentScalingPhase] == "hero")
      {
         updateHeroSize(errorBefore);
      }

      // IF PADDING PHASE
      else if(contentScalingPhases[cr_ContentScalingPhase] == "padding")
      {
         updatePaddingSize(errorBefore);
      }

      // Recalculate error
      let errorAfter = calculateScalingError();
      //if(abs(errorAfter) < abs(errorBefore))
   //}
}



/* Increase or decrease the font size depending on whether 'error' is positive or negative
   Returns true if font was updated or false if size limit was reached. */
function updateFontSize(error){
   console.log("DBG - Updating font size")

   // Update the font size variable
   if(error < 0)  // We need to shrink
   {
      cr_fontSize -= 0.5;
   }
   else if(error > SCALING_PERMISSIBLE_ERROR) // We need to expand
   {
      if(cr_fontSize < fontSizeMAX)
      {
         cr_fontSize += 0.5;
      }
      else
      {
         increaseScalingPhase(); 
      }
   }

   // Update the CSS
   /* NOTE: This is a bit weird - the second child of fp-main is a <p> tag. */
   document.getElementById("fp-main").children[2].style.fontSize = cr_fontSize + "pt";

   return true;
}


/* Increase or decrease the hero size depending on whether 'error' is positive or negative
   Returns true if size was updated or false if size limit was reached. */
function updateHeroSize(error){
   console.log("DBG - Updating hero size")

   // Prepare some variables
   var heroImage = document.getElementById("hero-image");
   var imageHeight = window.innerWidth * HERO_IMAGE_ASPECT_RATIO;

   // Update the hero size variable
   if(error < 0)  // We need to shrink
   {
      if(cr_heroImageVisible > heroImageVisibleMIN)
      {
         cr_heroImageVisible -= 5;
      }
      else
      {
         decreaseScalingPhase();
      }
   }
   else if(error > SCALING_PERMISSIBLE_ERROR) // We need to expand
   {
      if(cr_heroImageVisible < imageHeight)
      {
         cr_heroImageVisible += 5;
      }
      else
      {
         increaseScalingPhase();
      }
   }

   // Update CSS
   heroImage.style.top = (-imageHeight + cr_heroImageVisible) + "px";

   // Also update the padding on the top of fp-main so that it's always visible.
   document.getElementById("fp-main").style.top = cr_heroImageVisible + "px";
}


/* Increase or decrease the hero size depending on whether 'error' is positive or negative
   Returns true if size was updated or false if size limit was reached. */
   function updatePaddingSize(error){
      console.log("DBG - Updating padding size")
   
      if(error < 0)  // If we need to shrink
      {
         if(cr_padding > paddingMIN) 
         {
            cr_padding += error /4;
         }
         else
         {
            decreaseScalingPhase();
         }
      }
      else if(error > SCALING_PERMISSIBLE_ERROR) // We need to expand
      {
         if(cr_padding < paddingMAX)
         {
            cr_padding += error /4;
         }
         else
         {
            //increaseScalingPhase();
         }
      }
   
      // Update CSS
      document.getElementById("fp-main").style.padding = cr_padding + "px";
   }


function updateScalingPhase(error){
   if(error > 0)  // We need to increase the scaling phase
   {
      if(cr_ContentScalingPhase < NUM_SCALING_PHASES) // If we aren't at max phase
      {
         cr_ContentScalingPhase++;  // Increase phase
      }
   }
   else if(error < 0)   // We need to decrease the scaling phase
   {
      if(cr_ContentScalingPhase > 0) // If we aren't at min phase
      {
         cr_ContentScalingPhase--;  // Decrease phase
      }
   }
   console.log("updating scaling phase - new phase: " + contentScalingPhases[cr_ContentScalingPhase])
}


function increaseScalingPhase(){
   if(cr_ContentScalingPhase < NUM_SCALING_PHASES) // If we aren't at max phase
   {
      cr_ContentScalingPhase++;  // Increase phase
   }
   console.log("updating scaling phase - new phase: " + contentScalingPhases[cr_ContentScalingPhase])
}


function decreaseScalingPhase(){
   if(cr_ContentScalingPhase > 0) // If we aren't at min phase
   {
      cr_ContentScalingPhase--;  // Decrease phase
   }
   console.log("updating scaling phase - new phase: " + contentScalingPhases[cr_ContentScalingPhase])
}


function calculateScalingError(){
   let windowHeight = window.innerHeight;
   let fpMainHeight = window.getComputedStyle(document.getElementById('fp-main'), null).getPropertyValue("height").slice(0, -2);
   let totalContentHeight = parseInt(fpMainHeight) + cr_heroImageVisible;

   return windowHeight - totalContentHeight;
}


// EXPORT FUNCTIONS
export { updateHeroPosition, 
         updateLayout,
         initializeLayout 
      };